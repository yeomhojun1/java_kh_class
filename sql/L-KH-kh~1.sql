select* from EMPLOYEE;
select* from DEPARTMENT;
select* from JOB;
select* from LOCATION;
select* from SAL_GRADE;
--급여를 350000보다 많고 400000보다 적은사람 직원이름과 급여 조회

select EMP_Name, SALARY
from EMPLOYEE
WHERE SALARY BETWEEN 3500000 AND 6000000;

select EMP_Name, SALARY
from EMPLOYEE
WHERE EMP_NAME LIKE '전%';

select EMP_Name, EMAIL
from EMPLOYEE
WHERE phone LIKE'___7%';

select EMP_Name, email, emp_no
from EMPLOYEE
WHERE EMP_NAME NOT LIKE '이%';

select EMP_Name
from EMPLOYEE
WHERE manager_id IS NULL AND dept_code IS NULL;

select EMP_Name
from EMPLOYEE
WHERE dept_code IS NULL AND bonus IS NOT NULL;

select EMP_Name
from EMPLOYEE
WHERE job_code LIKE 'J1';

select EMP_Name
from EMPLOYEE
WHERE ENAME LIKE '__@@_' ESCAPE '@';

select length(emp_name) len, length(emp_name) byteLen
    from employee
    ;

select email, instr(email, '@',8)위치 
from employee;

-- email 은 @ 이후에 .이 1개이상 있어야함.
select email, instr(email, '@'), instr(email, '.', instr(email, '@'))위치 
from employee
where instr(email,'.', instr(email, '@')) <>0;

select INSTR('ORACLEWELCOME','O', 2)
FROM DUAL;
select INSTR('ORACLEWELCOME','O', 1,2)
FROM DUAL;
select INSTR('ORACLEWELCOME','O',1,3)
FROM DUAL;
select INSTR('ORACLEWELCOMEOKEY','O',3,2)
FROM DUAL;
--SYSDATE는 함수는 아니나 명령어가 실행되는 시점에 결과값을 출력해줘서 함수호출과 같은 느낌임

select emp_name,emp_no,decode(substr(emp_no,8,1),2,'여',3,'남',4,'여',1, '남','그외') as "성별"
from employee
;
select substr(emp_no,8,1) from employee; 

select(substr(emp_no, 8,3) from employee;

if(substr(emp_no,8,1)==2){
return "여";
} else if(substr(emp_no,8,1)==1){
return "남";
}else if(substr(emp_no,8,1)==3){
return "남";
}else if(substr(emp_no,8,1)==4){
return "여";}else{
return "그외";
}

select emp_name,emp_no,
case to_number( substr(emp_no,8,1))
    when substr(emp_no,8,1)=2 then '여'
    when substr(emp_no,8,1)=1 then '남'
     when substr(emp_no,8,1)=4 then '여'
    when substr(emp_no,8,1)=3 then '남'
    else '그외'
    end
    as "성별"
from employee
;

desc tb_student;
select emp_name,emp_no,
case  substr(emp_no,8,1)
    when '1' then '남'
   when '2' then '여'
   when '3' then '남'
   when '4' then '여'
    else '그외'
    end
    as "성별"
from employee
;
select avg(salary) 평균급여 from employee;
select floor(avg(salary)) 평균급여 from employee;
select round(avg(salary)) 평균급여 from employee;
select ceil(avg(salary)) 평균급여 from employee;
select trunc(avg(salary),2) 평균급여 from employee;

select count(distinct dept_code) from employee;
select count(dept_code) from employee;--21
select count(*) from employee;--23
select count(*) from employee where dept_code is null;
select* from employee group by dept_code;--23
select count(dept_code), dept_code from employee group by dept_code;
--count 는 resultset의 row값이 null이라면 count 하지않음
--아래 식은 null이 몇개인지 아는것
select count(dept_code), count(bonus) from employee where dept_code is null;
--distinct는 중복값을 1개로 보고 인정함

select count(dept_code), count(distinct dept_code)
from employee;

--사원명, 부서번호,부서명, 부서위치를 조회
SELECT tb1.emp_name, tb1.dept_code,dept_title, tb2.location_id,tb3.national_code, tb4.national_name
    from employee tb1
    join department tb2 on tb1.dept_code=tb2.dept_id
    join location tb3 on tb2.location_id= tb3.local_code
    join national tb4 on tb3.national_code= tb4.national_code
;
--using을 썼을때는 national_code가 하나로 합쳐져서 앞에 national.같은걸 써주면 안됨
SELECT tb1.emp_name, tb1.dept_code,dept_title, tb2.location_id,national_code, tb4.national_name
    from employee tb1
    join department tb2 on tb1.dept_code=tb2.dept_id
    join location tb3 on tb2.location_id= tb3.local_code
    join national tb4  using (national_code)
;



--두개가 결과가 같음 여기는 where과 and를 사용
SELECT tb1.emp_name, tb1.dept_code,dept_title, tb2.location_id,tb3.national_code, tb4.national_name
    from employee tb1,department tb2, location tb3, national tb4
     where tb1.dept_code=tb2.dept_id
     and tb2.location_id= tb3.local_code
     and tb3.national_code= tb4.national_code
;
--FROM 뒤에 나오는 EMPLOYEE가 기준임
SELECT *
FROM EMPLOYEE E
JOIN DEPARTMENT D ON E.dept_code= D.dept_id;

SELECT *
FROM EMPLOYEE E
LEFT OUTER JOIN DEPARTMENT D ON E.dept_code= D.dept_id
;
SELECT  DEPT_CODE, JOB_CODE, mANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE, MANAGER_ID;

SELECT  DEPT_CODE, JOB_CODE, mANAGER_ID, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY GROUPING SETS((DEPT_CODE, JOB_CODE, MANAGER_ID),
(DEPT_CODE, MANAGER_ID), (JOB_CODE,MANAGER_ID));




CREATE TABLE USER_NOTNULL(

USER_NO NUMBER NOT NULL,
USER_ID VARCHAR2(20) NOT NULL,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50)

);
INSERT INTO USER_NOTNULL VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');
--단일 인용부를 지정해 주십시오 따옴표가 PPT에 있던것과 다름

CREATE TABLE USER_UNIQUE(
USER_NO NUMBER,
USER_ID VARCHAR2(20) UNIQUE,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50)

);
INSERT INTO USER_UNIQUE VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');

CREATE TABLE USER_UNIQUE2(
USER_NO NUMBER,
USER_ID VARCHAR2(20),
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50),
UNIQUE (USER_ID) --테이블 레벨

);
INSERT INTO USER_UNIQUE2 VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');
INSERT INTO USER_UNIQUE2 VALUES(1, 'user01', 'pass01', NULL, NULL, '010-1234-5678',
'hong123@kh.or.kr');
INSERT INTO USER_UNIQUE2 VALUES(1, NULL, 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');
INSERT INTO USER_UNIQUE2 VALUES(1, NULL, 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');


CREATE TABLE USER_UNIQUE3(
USER_NO NUMBER,
USER_ID VARCHAR2(20),
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50),
UNIQUE (USER_NO, USER_ID) --두 컬럼을 묶어 한 UNIQUE제약조건 설정

);
select* from user_unique3;
INSERT INTO USER_UNIQUE3 VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-
5678', 'hong123@kh.or.kr');
INSERT INTO USER_UNIQUE3 VALUES(2, 'user01', 'pass01', NULL, NULL, '010-1234-
5678', 'hong123@kh.or.kr');
INSERT INTO USER_UNIQUE3 VALUES(2, 'user02', 'pass02', NULL, NULL, '010-1234-
5678', 'hong123@kh.or.kr');

CREATE TABLE USER_PRIMARYKEY(
USER_NO NUMBER PRIMARY KEY,
USER_ID VARCHAR2(20) UNIQUE,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50)
);

CREATE TABLE USER_PRIMARYKEY2(
USER_NO NUMBER,
USER_ID VARCHAR2(20) UNIQUE,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50),
PRIMARY KEY (USER_NO)
);

INSERT INTO USER_PRIMARYKEY VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');
--아래줄은 무결성 제약 조건(KH.SYS_C008439)에 위배됩니다 오류남 왜냐면 P키가 중복됨
INSERT INTO USER_PRIMARYKEY VALUES(1, 'user02', 'pass02', '이순신', '남', '010-5678-9012', 'lee123@kh.or.kr');
--아래줄은 NULL을 ("KH"."USER_PRIMARYKEY"."USER_NO") 안에 삽입할 수 없습니다 오류남, 왜냐면 NOT NULL이기때문에
INSERT INTO USER_PRIMARYKEY VALUES(NULL, 'user03', 'pass03', '유관순', '여', '010-3131-3131',
'yoo123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2 VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-
1234-5678', 'hong123@kh.or.kr');
--아래줄은 무결성 제약 조건(KH.SYS_C008442)에 위배됩니다 오류남 왜냐면 P키인 USER_NO이 같아서
INSERT INTO USER_PRIMARYKEY2 VALUES(1, 'user02', 'pass02', '이순신', '남', '010-
5678-9012', 'lee123@kh.or.kr');
--아래줄은 무결성 제약 조건(KH.SYS_C008442)에 위배됩니다 오류남 왜냐면 UNIQUE키인 USERID가 처음행과 같아서
INSERT INTO USER_PRIMARYKEY2 VALUES(2, 'user01', 'pass01', '유관순', '여', '010-
3131-3131', 'yoo123@kh.or.kr');

CREATE TABLE USER_GRADE(

GRADE_CODE NUMBER PRIMARY KEY,
GRADE_NAME VARCHAR2(30) NOT NULL

);
INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');
 
CREATE TABLE USER_FOREIGNKEY(

    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
   
    FOREIGN KEY (GRADE_CODE)  
    --여기 constraint 이름 정해주기
    --fk_user_foreignkey-grade_code_user_grade
    constraint fk_user_foreignkey-grade_code_user_grade
    REFERENCES USER_GRADE( GRADE_CODE) on delete set null
);

INSERT INTO USER_FOREIGNKEY
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr', 10);
INSERT INTO USER_FOREIGNKEY
VALUES(2, 'user02', 'pass02', '이순신', '남', '010-9012-3456', 'lee123@kh.or.kr', 20);
INSERT INTO USER_FOREIGNKEY
VALUES(3, 'user03', 'pass03', '유관순', '여', '010-3131-3131', 'yoo123@kh.or.kr', 30);
INSERT INTO USER_FOREIGNKEY
VALUES(4, 'user04', 'pass04', '신사임당', '여', '010-1111-1111', 'shin123@kh.or.kr',
NULL);
--무결성 제약조건(KH.SYS_C008451)이 위배되었습니다- 부모 키가 없습니다 왜냐면 GRADE_CODE가 10,20,30밖에 없음
INSERT INTO USER_FOREIGNKEY
VALUES(5, 'user05', 'pass05', '안중근', '남', '010-4444-4444', 'ahn123@kh.or.kr', 50);
drop table USER_FOREIGNKEY;

CREATE TABLE USER_FOREIGNKEY(

USER_NO NUMBER PRIMARY KEY,
USER_ID VARCHAR2(20) UNIQUE,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50),
GRADE_CODE NUMBER,
FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE( GRADE_CODE) on delete set null
);

INSERT INTO USER_FOREIGNKEY
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr', 10);
INSERT INTO USER_FOREIGNKEY
VALUES(2, 'user02', 'pass02', '이순신', '남', '010-9012-3456', 'lee123@kh.or.kr', 20);
INSERT INTO USER_FOREIGNKEY
VALUES(3, 'user03', 'pass03', '유관순', '여', '010-3131-3131', 'yoo123@kh.or.kr', 30);
INSERT INTO USER_FOREIGNKEY
VALUES(4, 'user04', 'pass04', '신사임당', '여', '010-1111-1111', 'shin123@kh.or.kr',
NULL);

DELETE FROM USER_GRADE WHERE GRADE_CODE = 10;
select * from USER_FOREIGNKEY;

CREATE TABLE USER_CHECK(

USER_NO NUMBER PRIMARY KEY,
USER_ID VARCHAR2(20) UNIQUE,
USER_PWD VARCHAR2(30) NOT NULL,
USER_NAME VARCHAR2(30),
GENDER VARCHAR2(10) CHECK (GENDER IN ('남', '여')),
PHONE VARCHAR2(30),
EMAIL VARCHAR2(50)

);
INSERT INTO USER_CHECK VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678',
'hong123@kh.or.kr');

INSERT INTO EMPLOYEE
VALUES(1, '홍길동', '820114-1010101', 'hong_kd@kh.or.kr', '01099998888', 'D5', 'J2', 'S4', 3800000,

NULL, '200', SYSDATE, NULL, DEFAULT);
SELECT * FROM EMPLOYEE;
UPDATE EMPLOYEE
SET EMP_ID = 290
WHERE EMP_NAME = '홍길동';

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '홍길동';

INSERT INTO EMPLOYEE
VALUES(900, '장채현', '901123-1080503', 'jang_ch@kh.or.kr', '01055569512', 'D1', 'J8',

'S3', 4300000, 0.2, '200', SYSDATE, NULL, DEFAULT);

CREATE TABLE EMP_01(
EMP_ID NUMBER,
EMP_NAME VARCHAR2(30),
DEPT_TITLE VARCHAR2(20)

);
SELECT * FROM EMP_01;
INSERT INTO EMP_01(
SELECT EMP_ID,
EMP_NAME,
DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)

);

CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE 1 = 0;

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE
WHERE 1 = 0;

INSERT ALL
INTO EMP_DEPT_D1 VALUES(EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE)
INTO EMP_MANAGER VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE, MANAGER_ID
FROM EMPLOYEE
WHERE DEPT_CODE = 'D1';

SELECT * FROM EMP_MANAGER ;
SELECT * FROM EMP_DEPT_D1 ;

CREATE TABLE EMP_OLD
AS SELECT EMP_ID,EMP_NAME,HIRE_DATE,SALARY
FROM EMPLOYEE
WHERE 1 = 0;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID,EMP_NAME,HIRE_DATE,SALARY
FROM EMPLOYEE
WHERE 1 = 0;

INSERT ALL
WHEN HIRE_DATE < '2000/01/01' THEN

INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)

WHEN HIRE_DATE >= '2000/01/01' THEN

INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)

SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;
UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획팀'
WHERE DEPT_ID = 'D9';

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY,BONUS
FROM EMPLOYEE;
SELECT * FROM EMP_SALARY;

UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
BONUS = (SELECT BONUS FROM EMP_SALARY  WHERE EMP_NAME='유재식')
WHERE EMP_NAME = '방명수';

UPDATE EMP_SALARY
SET (SALARY, BONUS) = (SELECT SALARY, BONUS
FROM EMP_SALARY
WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식', '방명수');

UPDATE EMP_SALARY
SET BONUS = 0.3
WHERE EMP_ID IN (SELECT EMP_ID
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_ID = DEPT_CODE)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
WHERE LOCAL_NAME LIKE 'ASIA%');

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '장채현';

DELETE FROM DEPARTMENT
WHERE DEPT_ID = 'D1';

ALTER TABLE EMPLOYEE
DISABLE CONSTRAINT EMP_DEPTCODE_FK CASCADE;

ALTER TABLE EMPLOYEE
ENABLE CONSTRAINT EMP_DEPTCODE_FK;

TRUNCATE TABLE EMP_SALARY;
SELECT * FROM EMP_SALARY;
ROLLBACK;

ALTER TABLE DEPT_COPY
ADD (CNAME VARCHAR2(20));

ALTER TABLE DEPT_COPY
ADD (LNAME VARCHAR2(40) DEFAULT '한국');

ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_DID_PK PRIMARY KEY(DEPT_ID);
DESC DEPT_COPY;
ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_DTITLE_UNQ UNIQUE(DEPT_TITLE);
ALTER TABLE DEPT_COPY
MODIFY LNAME CONSTRAINT DCOPY_LNAME_NN NOT NULL;

SELECT UC.CONSTRAINT_NAME,
UC.CONSTRAINT_TYPE,
UC.TABLE_NAME,
UCC.COLUMN_NAME,
UC.SEARCH_CONDITION
FROM USER_CONSTRAINTS UC
JOIN USER_CONS_COLUMNS UCC ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
WHERE UC.TABLE_NAME = 'DEPT_COPY';

SELECT * FROM DEPT_COPY;

ALTER TABLE DEPT_COPY
MODIFY DEPT_ID CHAR(3)
MODIFY DEPT_TITLE VARCHAR(30)
MODIFY LOCATION_ID VARCHAR2(2)
MODIFY CNAME CHAR(20) 
MODIFY LNAME DEFAULT '미국';

ALTER TABLE DEPT_COPY
DROP COLUMN DEPT_ID;

CREATE TABLE TB1(

PK NUMBER PRIMARY KEY,
FK NUMBER REFERENCES TB1,
COL1 NUMBER,
CHECK(PK > 0 AND COL1 > 0)

);

ALTER TABLE TB1
DROP COLUMN PK;

ALTER TABLE TB1
DROP COLUMN PK CASCADE CONSTRAINT;

ALTER TABLE DEPT_COPY
--DROP CONSTRAINT DCOPY_DID_PK
--DROP CONSTRAINT DCOPY_DTITLE_UNQ
MODIFY LNAME NULL;

ALTER TABLE DEPT_COPY
RENAME COLUMN DEPT_TITLE TO DEPT_NAME;

SELECT UC.CONSTRAINT_NAME 이름,
UC.CONSTRAINT_TYPE 유형,
UCC.COLUMN_NAME 컬럼명,
UC.R_CONSTRAINT_NAME 참조,
UC.DELETE_RULE 삭제규칙

FROM USER_CONSTRAINTS UC
JOIN USER_CONS_COLUMNS UCC ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
WHERE UC.TABLE_NAME = 'USER_FOREIGNKEY';


ALTER TABLE USER_FOREIGNKEY
RENAME CONSTRAINT SYS_C008468 TO UF_UN_PK;

ALTER TABLE USER_FOREIGNKEY
RENAME CONSTRAINT SYS_C008469 TO UF_UI_UQ;

ALTER TABLE USER_FOREIGNKEY
RENAME CONSTRAINT SYS_C008470 TO UF_GC_FK;

ALTER TABLE DEPT_COPY
RENAME TO DEPT_TEST;

DROP TABLE DEPT_TEST CASCADE CONSTRAINT;

--PPT 9번
CREATE OR REPLACE VIEW V_EMPLOYEE
AS SELECT EMP_ID, EMP_NAME, DEPT_TITLE, NATIONAL_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_ID = DEPT_CODE)
LEFT JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
LEFT JOIN NATIONAL USING(NATIONAL_CODE);

SELECT * FROM V_EMPLOYEE;

CREATE OR REPLACE VIEW V_EMP_JOB(사번, 이름, 직급, 성별, 근무년수)
AS SELECT EMP_ID, EMP_NAME, JOB_NAME,
DECODE(SUBSTR(EMP_NO, 8, 1), 1, '남', 2, '여'),
EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

CREATE OR REPLACE VIEW V_JOB(JOB_CODE, JOB_NAME)
AS SELECT JOB_CODE, b.JOB_NAME
FROM JOB A
JOIN JOB B USING(JOB_CODE);

INSERT INTO V_JOB VALUES('J8', '인턴');

SELECT * FROM V_JOB;
SELECT * FROM JOB;

CREATE OR REPLACE VIEW V_JOB2
AS SELECT JOB_CODE
FROM JOB;

INSERT INTO V_JOB2 VALUES('J8', '인턴');

SELECT * FROM USER_INDEXES;

CREATE SYNONYM EMP FOR EMPLOYEE;

SELECT * FROM KH.DEPT;

CREATE PUBLIC SYNONYM DEPT_PUBLIC FOR KH.DEPT;
SELECT * FROM DEPT_PUBLIC;
CREATE PUBLIC SYNONYM DEPT_PUBLIC2 FOR KH.DEPT;
SELECT * FROM DEPT_PUBLIC;

DESC V_JOB;
SELECT * FROM DEPT_COPY;
--20230717 GROUP BY

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)
ORDER BY 1;

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE)
ORDER BY 1;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY 1;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
UNION
SELECT '', JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)
ORDER BY 1;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY),

CASE 
--0 : 해당 컬럼으로 GROUPING 안된상태, 1 : 해당하는 컬럼으로 GROUPING 된 상태
    WHEN GROUPING(DEPT_CODE) = 0 AND
    GROUPING(JOB_CODE) = 1
THEN '부서별 합계'
    WHEN GROUPING(DEPT_CODE) = 1 AND
    GROUPING(JOB_CODE) = 0
THEN '직급별 합계'
    WHEN GROUPING(DEPT_CODE) = 1 AND
    GROUPING(JOB_CODE) = 1
THEN '총 합계'
ELSE '그룹별 합계'
END AS 구분
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;
--WINDOW - OVER (PARTITION BY ..)
SELECT DEPTNO, EMPNO, SAL, ENAME,SUM(SAL) OVER(PARTITION BY DEPTNO) SUMSAL
FROM EMP
;
--WINDOW - OVER (ORDER BY ..)
SELECT DEPTNO, EMPNO, SAL, ENAME, RANK() OVER(ORDER BY SAL ASC) RANKSAL
FROM EMP
;
--ROWNUM
SELECT DEPTNO, EMPNO, SAL, ENAME,RN RANKSAL
FROM (SELECT ROWNUM RN, T1.*FROM (SELECT DEPTNO, EMPNO, ENAME, SAL FROM EMP ORDER BY SAL ASC) T1)
;
SELECT DEPTNO, EMPNO, SAL, ENAME, 
RANK() OVER(ORDER BY SAL ASC) RANKSAL, --같은 등수를 확인하고 같은 등수를 따로 생각함
DENSE_RANK() OVER(ORDER BY SAL ASC) DRANKSAL --같은 등수를 확인하고 같은 등수를 하나로 생각함, 인원수보다 작을수있음
,ROW_NUMBER() OVER(ORDER BY SAL ASC) RNSAL --같은 등수로 인식하지않음
,RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL ASC) DEPT_SAL_RANK
FROM EMP
ORDER BY DEPTNO
;
--부서코드가 30인 직원의 이름, 급여 급여에 관한 누적 분산을 조회
SELECT ENAME, SAL,DEPTNO
    , TRUNC(CUME_DIST() OVER(PARTITION BY DEPTNO ORDER BY SAL),2) SAL_CUME_DIST
    ,TRUNC(RATIO_TO_REPORT(SAL) OVER(PARTITION BY DEPTNO),2) SAL_RATIO
FROM EMP
--WHERE DEPTNO=10
;

SELECT DEPTNO, ENAME, SAL
, FIRST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS DEPT_RICH
, LAST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS DEPT_POOR --ERROR
, LAST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC ROWS BETWEEN CURRENT ROW  AND UNBOUNDED FOLLOWING) AS DEPT_POOR
FROM EMP;


select * from tb_department;

select * from tb_student;
select  student_name,  case when substr(student_ssn,14,1)=1   then '초4'
when substr(student_ssn,14,1)=2  then '초5'
when (substr(student_ssn,14,1)=3) then '초6'
when (substr(student_ssn,14,1)=4) then '중1'
when (substr(student_ssn,14,1)=5 ) then '중2'
else '중3' 
end  학년 
,student_no
,'010-'||substr(student_ssn,10,4)||'-'||substr(student_ssn,3,4) 부모전화번호
from tb_student ;

CREATE TABLE smyhj
AS SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY,BONUS
FROM tb_student;
SELECT * FROM EMP_SALARY;


select * from
(
select tb1.*, rownum rn from
(select * from tb_student 
order by student_no) tb1
) tb2
where rn between 6 and 10
;

CREATE TABLE SMY( 
STUDENT_NO VARCHAR2(30) NOT NULL,
STUDENT_NAME VARCHAR2(30) NOT NULL,
AGE NUMBER(2) NOT NULL,
PHONE VARCHAR2(30) NOT NULL,

PRIMARY KEY (STUDENT_NO)
);
;
insert all
into smy (STUDENT_NO,STUDENT_NAME,AGE,PHONE ) values (STUDENT_NO, STUDENT_NAME,AGE,PHONE )
SELECT STUDENT_NO, STUDENT_NAME, EXTRACT(YEAR FROM SYSDATE)- (SUBSTR(STUDENT_SSN,1,2)+2000) AGE, '010-'||substr(student_ssn,10,4)||'-'||substr(student_ssn,2,4) PHONE
FROM SM
;

DROP TABLE SMY;
SELECT * FROM SMY;

--TO_NUMBER(0000)
SELECT STUDENT_NO, STUDENT_NAME, EXTRACT(YEAR FROM SYSDATE)- (SUBSTR(STUDENT_SSN,1,2)+2000) AGE, '010-'||substr(student_ssn,10,4)||'-'||substr(student_ssn,2,4) PHONE
FROM SM;

